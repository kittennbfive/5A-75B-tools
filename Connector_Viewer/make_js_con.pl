#! /usr/bin/perl

=pod
This script creates data.js using connectors.storable, buffer_con.storable and fpga_pins.storable.

(c) 2020-2022 by kittennbfive
AGPLv3+
THIS CODE IS PROVIDED WITHOUT ANY WARRANTY!
=cut

use strict;
use warnings FATAL=>'all';
use autodie;
use Storable;

my %connectors; #{J<n>}->{<pin>}={ buffer=>U<n>, bit=><bitnr>, fpga_pin=><alphanum> }
%connectors=%{retrieve('connectors.storable')};

my %buffer_con; #{U<n>}->{<bitnr>}=[{ con=>J<n>, pin=><n> }]
%buffer_con=%{retrieve('buffer_con.storable')};

my %fpga; #{<alphanum>}->[J<n>_<n>];
%fpga=%{retrieve('fpga_pins.storable')};

open my $out, '>', 'data.js';

print $out <<"END1";
//AUTOGENERATED FILE - DO NOT EDIT

//(c) 2020-2022 by kittennbfive
//AGPLv3+
//NO WARRANTY!

const connectors=new Map(
[
END1

foreach my $j (sort keys %connectors)
{
	print $out "\t['$j', new Map(\n";
	print $out "\t\t[\n";
	foreach my $pin (sort {$a <=> $b} keys %{$connectors{$j}})
	{
		print $out "\t\t\t['$pin', new Map(\n";
		print $out "\t\t\t\t[\n";
		print $out "\t\t\t\t\t['buffer','",$connectors{$j}->{$pin}->{buffer},"'],\n";
		print $out "\t\t\t\t\t['bit','",$connectors{$j}->{$pin}->{bit},"'],\n";
		print $out "\t\t\t\t\t['fpga_pin','",$connectors{$j}->{$pin}->{fpga_pin},"'],\n";
		print $out "\t\t\t\t\t['directly_connected_to',\n";
		print $out "\t\t\t\t\t\t[\n";
		my @direct=get_direct_cons($j, $pin);
		my @arr=@direct;
		map({ $_="'$_'" } @arr);
		print $out "\t\t\t\t\t\t\t", join(', ', @arr),"\n" if(scalar(@arr));
		print $out "\t\t\t\t\t\t]\n";
		print $out "\t\t\t\t\t],\n";
		
		print $out "\t\t\t\t\t['same_fpga_pin',\n";
		print $out "\t\t\t\t\t\t[\n";
		list_same_fpga_pin($connectors{$j}->{$pin}->{fpga_pin}, $j, $pin, @direct);
		print $out "\t\t\t\t\t\t]\n";
		print $out "\t\t\t\t\t],\n";
		
		
		print $out "\t\t\t\t])\n";
		print $out "\t\t\t],\n";
	}
	print $out "\t\t])\n";
	print $out "\t],\n";
}

print $out "]);\n";

print $out "\n\n";
print $out "const buffer=new Map(\n";
print $out "[\n";
foreach my $buf (sort keys %buffer_con)
{
	print $out "\t['$buf', [";
	my @arr;
	foreach my $bitnr (sort keys %{$buffer_con{$buf}})
	{
		push @arr, @{$buffer_con{$buf}->{$bitnr}};
	}
	map({ $_='\'pin_'.$_->{con}.'_'.$_->{pin}.'\'' } @arr);
	print $out join(', ', @arr);
	print $out "] ],\n";
}
print $out "]);\n";

close $out;

########################################################################

sub get_direct_cons
{
	my ($j, $pin)=(shift, shift);
	my $buf=$connectors{$j}->{$pin}->{buffer};
	my $bit=$connectors{$j}->{$pin}->{bit};
	my @others=@{$buffer_con{$buf}->{$bit}};
	my @r;
	foreach my $ref (@others)
	{
		my $c=$ref->{con};
		my $p=$ref->{pin};
		next if($c eq $j && $p==$pin);
		push @r, $c."_".$p;
	}
	
	return @r;
}

sub list_same_fpga_pin
{
	no warnings "experimental";
	my ($pin_fpga, $j, $pin_j, @directs)=(shift, shift, shift, @_);
	
	my $con=$j."_".$pin_j;

	foreach my $c (@{$fpga{$pin_fpga}})
	{
		next if($c eq $con);
		next if ($c ~~ @directs);
			
		print $out "\t\t\t\t\t\t\t'$c',\n";
	}
}
